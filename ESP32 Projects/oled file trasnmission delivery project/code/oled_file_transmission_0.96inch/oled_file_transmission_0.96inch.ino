#include <SPI.h>
#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>
#include <ELECHOUSE_CC1101_SRC_DRV.h>
#include "FS.h"
#include "SD.h"
#include<SPI.h>


float cc1101_mhz = 433.92;
#define CCGDO0 2 //GPIO2
#define CCGDO2 4 //GPIO4

// Declaration for an SSD1306 display connected to I2C (SDA, SCL pins)
#define SCREEN_WIDTH 128 // OLED display width, in pixels
#define SCREEN_HEIGHT 32 // OLED display height, in pixels
#define OLED_RESET -1    // Reset pin # (or -1 if sharing Arduino reset pin)
#define NUM_FILES 50     // Maximum number of files to display
#define SCROLL_DELAY 200 // Delay between scrolls, in milliseconds

Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);


#define UP_BUTTON_PIN 26 // Pin for up button
#define DOWN_BUTTON_PIN 32 // Pin for down button
#define SELECT_BUTTON_PIN 33 // Pin for select button
#define RETURN_BUTTON_PIN 25 // Pin for return button

#define MAX_FILE_COUNT 50 // Maximum number of files/folders to display
#define MAX_NAME_LENGTH 20 // Maximum length of file/folder names

#define SD_CLK_PIN       14
#define SD_MOSI_PIN      13
#define SD_MISO_PIN     27
#define SD_CS_PIN        15    //15  // or 5





// Define a struct to hold file/folder information
struct FileInfo {
  char name[MAX_NAME_LENGTH];
  bool isFolder;
};

FileInfo fileList[MAX_FILE_COUNT]; // Array to hold file/folder information
int fileCount = 0; // Number of files/folders in the array
int currentIndex = 0; // Index of the currently highlighted file/folder
int firstIndex = 0; // Index of the first file/folder to display on the screen
int lastIndex = 0; // Index of the last file/folder to display on the screen

// FUNCTION HEADERS
void sendSamples(int samples[], int samplesLenght);
String fileToTransmit = "";


SPIClass SPISD(HSPI);

String path_folder = "";
bool fold = false;

const unsigned char epd_bitmap_SUB [] PROGMEM = {
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0x00, 0x7f, 0xff, 0xfe, 0x0f, 0xff, 0xc0, 0x1f, 0x87, 0x07, 0x80, 0x03, 0xff,
  0xff, 0xff, 0xfe, 0x00, 0xff, 0xff, 0xfe, 0x1f, 0xff, 0x80, 0x3f, 0x0f, 0x0f, 0x00, 0x07, 0xff,
  0xff, 0xff, 0xf8, 0x78, 0x7f, 0xff, 0xfc, 0x3f, 0xfc, 0x1c, 0x1e, 0x1e, 0x1f, 0xff, 0x0f, 0xff,
  0xff, 0xff, 0xf0, 0xf0, 0xff, 0xff, 0xf8, 0x7f, 0xf8, 0x3c, 0x3c, 0x3c, 0x3f, 0xfe, 0x1f, 0xff,
  0xff, 0xff, 0xe1, 0xff, 0xe0, 0xe0, 0xf0, 0x01, 0xf8, 0x78, 0x78, 0x38, 0x3f, 0xfc, 0x3f, 0xff,
  0xff, 0xff, 0xc1, 0xff, 0xe1, 0xe1, 0xe0, 0x03, 0xf0, 0xf0, 0xf0, 0x70, 0x7f, 0xf8, 0x7f, 0xff,
  0xff, 0xff, 0xe0, 0xff, 0xc3, 0xc3, 0xc1, 0xc1, 0xe1, 0xff, 0xe0, 0xf0, 0xff, 0xc3, 0xff, 0xff,
  0xff, 0xff, 0xe1, 0xff, 0x87, 0x87, 0x83, 0xc3, 0xc1, 0xff, 0xe0, 0xe1, 0xff, 0x83, 0xff, 0xff,
  0xff, 0xff, 0xf0, 0xff, 0x07, 0x07, 0x87, 0x87, 0x83, 0xff, 0xc0, 0x03, 0xfc, 0x1f, 0xff, 0xff,
  0xff, 0xff, 0xe0, 0xfe, 0x0e, 0x0f, 0x0f, 0x0f, 0x07, 0xff, 0x80, 0x03, 0xf8, 0x3f, 0xff, 0xff,
  0xff, 0xff, 0xf0, 0xfc, 0x1e, 0x1e, 0x1e, 0x1f, 0x0c, 0x0f, 0x07, 0x0f, 0xe1, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xf0, 0x7c, 0x3c, 0x3c, 0x1c, 0x1e, 0x18, 0x1e, 0x0e, 0x0f, 0x03, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xf0, 0x78, 0x78, 0x78, 0x38, 0x3c, 0x3c, 0x3c, 0x1e, 0x1e, 0x0f, 0xff, 0xff, 0xff,
  0xff, 0xe1, 0xe0, 0xf0, 0xf0, 0x78, 0x78, 0x78, 0x78, 0x3c, 0x3c, 0x3c, 0x3f, 0xff, 0xff, 0xff,
  0xff, 0xe1, 0xe1, 0xe0, 0xe0, 0xf0, 0xf0, 0xf0, 0x70, 0x78, 0x78, 0x78, 0x3f, 0xff, 0xff, 0xff,
  0xff, 0xe0, 0x0f, 0xf0, 0x01, 0xe0, 0x07, 0xf8, 0x00, 0xf0, 0xf0, 0xf0, 0x00, 0xff, 0xff, 0xff,
  0xff, 0xe0, 0x1f, 0xe0, 0x03, 0xc0, 0x07, 0xf8, 0x01, 0xe0, 0xe0, 0xf0, 0x00, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xfc, 0x00, 0x7e, 0x1f, 0xff, 0xe0, 0xff, 0x0f, 0x07, 0x80, 0x07, 0x80, 0x0f, 0xff,
  0xff, 0xff, 0xfc, 0x00, 0xfc, 0x1f, 0xff, 0xe1, 0xfe, 0x0e, 0x0f, 0x00, 0x0f, 0x00, 0x1f, 0xff,
  0xff, 0xff, 0xf8, 0x78, 0x78, 0x3f, 0xff, 0x00, 0xfc, 0x1c, 0x1e, 0x1f, 0xff, 0x0f, 0x0f, 0xff,
  0xff, 0xff, 0xf0, 0xf0, 0xf0, 0x7f, 0xfe, 0x01, 0xfc, 0x3c, 0x3c, 0x1f, 0xfe, 0x1e, 0x1f, 0xff,
  0xff, 0xff, 0xe0, 0xe0, 0xe0, 0xff, 0xf0, 0x70, 0x78, 0x78, 0x78, 0x3f, 0xfc, 0x3c, 0x3f, 0xff,
  0xff, 0xff, 0xc1, 0xc1, 0xe1, 0xff, 0xe0, 0xe0, 0xf0, 0xf0, 0xf0, 0x7f, 0xf8, 0x78, 0x3f, 0xff,
  0xff, 0xff, 0x83, 0x83, 0xc3, 0xff, 0xe1, 0xe1, 0xe1, 0xe0, 0xf0, 0xff, 0xf0, 0xf0, 0x7f, 0xff,
  0xff, 0xff, 0x87, 0x87, 0x87, 0xff, 0xc3, 0xc3, 0xc1, 0xc1, 0xe1, 0xff, 0xe0, 0xe0, 0xff, 0xff,
  0xff, 0xff, 0x00, 0x3f, 0x07, 0xff, 0x87, 0x87, 0xe0, 0x0f, 0xc0, 0x0f, 0xc0, 0x07, 0xff, 0xff,
  0xff, 0xfe, 0x00, 0x7e, 0x0f, 0xff, 0x07, 0x0f, 0xe0, 0x1f, 0x80, 0x1f, 0xc0, 0x0f, 0xff, 0xff,
  0xff, 0xfc, 0x3f, 0xfe, 0x1f, 0xfe, 0x00, 0x0f, 0xf0, 0xff, 0x07, 0xff, 0x86, 0x1f, 0xff, 0xff,
  0xff, 0xf8, 0x3f, 0xfc, 0x3f, 0xfc, 0x00, 0x1f, 0xe1, 0xfe, 0x0f, 0xff, 0x0c, 0x1f, 0xff, 0xff,
  0xff, 0xf0, 0x7f, 0xf8, 0x7f, 0xf8, 0x38, 0x3f, 0xc3, 0xfe, 0x1f, 0xfe, 0x0e, 0x0f, 0xff, 0xff,
  0xff, 0xe0, 0xff, 0xf0, 0x7f, 0xf8, 0x78, 0x7f, 0x83, 0xfc, 0x3f, 0xfc, 0x1c, 0x1f, 0xff, 0xff,
  0xff, 0xe1, 0xff, 0xe0, 0xff, 0xf0, 0xf0, 0xff, 0x07, 0xf8, 0x7f, 0xf8, 0x3c, 0x3f, 0xff, 0xff,
  0xff, 0xc3, 0xff, 0xc0, 0x03, 0xe1, 0xe1, 0xfe, 0x0f, 0xf0, 0x00, 0xf0, 0x78, 0x7f, 0xff, 0xff,
  0xff, 0x87, 0xff, 0xc0, 0x03, 0xc1, 0xc1, 0xfe, 0x1f, 0xe0, 0x00, 0xf0, 0xf0, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
};



void setup()
{
  Serial.begin(115200);
  SPI.begin();
  pinMode(CCGDO0, OUTPUT);
  pinMode(UP_BUTTON_PIN, INPUT_PULLUP);
  pinMode(DOWN_BUTTON_PIN, INPUT_PULLUP);
  pinMode(SELECT_BUTTON_PIN, INPUT_PULLUP);
  pinMode(RETURN_BUTTON_PIN, INPUT_PULLUP);

  display.begin(SSD1306_SWITCHCAPVCC, 0x3C);
  display.clearDisplay();
  display.setTextColor(WHITE);
  display.setTextSize(1);


  initCC1101();
  Serial.println("CC1101 Connection OK");

  SPISD.begin(SD_CLK_PIN, SD_MISO_PIN, SD_MOSI_PIN);

  initsd();

  display.drawBitmap(0, 0, epd_bitmap_SUB, 128, 32, WHITE);
  display.display();
  delay(2000);
  display.clearDisplay();
  loadFiles();
  currentIndex = 0;
  firstIndex = 0;
  lastIndex = min(fileCount - 1, SCREEN_HEIGHT / 8 - 1);
  displayList();
  displayList();
}

void initsd()
{
  if (!SD.begin(SD_CS_PIN, SPISD))
  {
    Serial.println("Card Mount Failed");
    while (1);
  }
  Serial.println("initialization done.");
}

void initCC1101() {
  ELECHOUSE_cc1101.setSpiPin(18, 19, 23, 5); // (SCK, MISO, MOSI, CSN);
  ELECHOUSE_cc1101.Init();
  ELECHOUSE_cc1101.setGDO(CCGDO0, CCGDO2);
  ELECHOUSE_cc1101.setMHZ(cc1101_mhz);        // Here you can set your basic frequency. The lib calculates the frequency automatically (default = 433.92).The cc1101 can: 300-348 MHZ, 387-464MHZ and 779-928MHZ. Read More info from datasheet.
  ELECHOUSE_cc1101.SetTx();               // set Transmit on
  ELECHOUSE_cc1101.setModulation(2);      // set modulation mode. 0 = 2-FSK, 1 = GFSK, 2 = ASK/OOK, 3 = 4-FSK, 4 = MSK.
  ELECHOUSE_cc1101.setDRate(512);         // Set the Data Rate in kBaud. Value from 0.02 to 1621.83. Default is 99.97 kBaud!
  ELECHOUSE_cc1101.setPktFormat(3);       // Format of RX and TX data. 0 = Normal mode, use FIFOs for RX and TX.
  // 1 = Synchronous serial mode, Data in on GDO0 and data out on either of the GDOx pins.
  // 2 = Random TX mode; sends random data using PN9 generator. Used for test. Works as normal mode, setting 0 (00), in RX.
  // 3 = Asynchronous serial mode, Data in on GDO0 and data out on either of the GDOx pins.

  if (!ELECHOUSE_cc1101.getCC1101()) {     // Check the CC1101 Spi connection.
    Serial.println("CC1101 Connection Error");
  }
}




void loop()
{
  navigator();
  if (fileToTransmit != "")
  {
    transmitFlipperFile(fileToTransmit, false);
    fileToTransmit = "";
  }
}



void handleFlipperCommandLine(String command, String value) {
  if (command == "Frequency") {
    float frequency = value.toFloat() / 1000000;
    Serial.print("Setting Frequency:");
    Serial.println(frequency);
    //ELECHOUSE_cc1101.setMHZ(frequency);
    cc1101_mhz = frequency;
  }
}


void transmitFlipperFile(String filename, bool transmit)
{
  File flipperFile;
  flipperFile.seek(0);

  if (fold == true)
  {
    String new_path = path_folder + "/" + filename;
    Serial.println("path to file in folder: " + new_path);
    flipperFile = SD.open(new_path, "r");

  }

  else
  {
    flipperFile = SD.open("/" + filename, "r");
  }
  if (transmit)
  {
    initCC1101();

  }
  initsd();

  Serial.println("file name to open in fucntion is:" + filename);

  if (!flipperFile)
  {
    Serial.println("The file cannot be opened");
  }
  else
  {
    // Serial.println("file opende");
    // PARSE CONTENT CHAR BY CHAR
    String command = "";
    String value = "";

    int data;
    char dataChar;
    bool appendCommand = true;
    bool breakLoop = false;
    int samples[512];
    int currentSample = 0;



    while ((data = flipperFile.read()) >= 0 && breakLoop == false)
    {
      dataChar = data;

      switch (dataChar) {
        case ':':
          appendCommand = false;
          break;
        case '\n':
          // REMOVE SPACES IN FRONT OF VALUE
          while (value.startsWith(" ")) {
            value = value.substring(1);
          }

          Serial.println("DUMP:");
          Serial.println(command + " | " + value);

          if (transmit == false) {
            // SETUP CC1101 PARAMETERS
            handleFlipperCommandLine(command, value);
          } else {
            // TRANSMIT ON PREVIOUSLY SETUP CC1101
            if (command == "RAW_Data" && transmit) {
              sendSamples(samples, 512);
            }
          }

          // GET READY FOR THE NEXT ROW
          appendCommand = true;
          command = "";
          value = "";
          currentSample = 0;
          memset(samples, 0, sizeof(samples));
          break;
        default:
          if (appendCommand) {
            command += String(dataChar);
          }
          else {
            value += String(dataChar);

            if (command == "RAW_Data") {
              if (dataChar == ' ') {
                // REPLACE SPACES IN CURRENT SAMPLE
                value.replace(" ", "");
                if (value != "") {
                  samples[currentSample] = value.toInt();
                  currentSample++;
                  value = "";
                }

              }
            }
          }
          break;
      }
    }
    flipperFile.close();
    if (transmit == false)
    {
      // START TRANSMITTING THE DATA
      fileToTransmit = filename;
      // Serial.println("fileToTransmit: " + filename);
      transmitFlipperFile(fileToTransmit, true);
    }

  }

}


void navigator()
{
  if (digitalRead(UP_BUTTON_PIN) == LOW)
  {
    Serial.println("up working");
    // Move the rectangle up one row
    currentIndex--;
    if (currentIndex < 0)
    {
      currentIndex = 0;
    }

    // Check if the first index needs to be updated
    if (currentIndex < firstIndex) {
      firstIndex--;
      lastIndex--;
    }

    // Update the display
    displayList();
    delay(500);
  }

  // Check if the down button is pressed
  if (digitalRead(DOWN_BUTTON_PIN) == LOW)
  {
    Serial.println("down working");
    // Move the rectangle down one row
    currentIndex++;
    if (currentIndex > fileCount - 1)
    {
      currentIndex = fileCount - 1;
    }

    // Check if the last index needs to be updated
    if (currentIndex > lastIndex)
    {
      lastIndex++;
      firstIndex++;
    }

    // Update the display
    displayList();
    delay(500);
  }

  // Check if the select button is pressed
  if (digitalRead(SELECT_BUTTON_PIN) == LOW)
  {
    delay(500);
    Serial.println("slecrt working");
    // Check if the current file/folder is a folder
    if (fileList[currentIndex].isFolder)
    {
      Serial.println(String(fileList[currentIndex].name) + "folder opend!");
      fold = true;
      Serial.println(fileList[currentIndex].name);
      if (path_folder == "")
      {
        Serial.println("folder of path is:");
        path_folder = "/" + String(fileList[currentIndex].name);
        Serial.println(path_folder);
      }
      else
      {
        Serial.println("something in folder of path: ");
        path_folder = path_folder + "/" + fileList[currentIndex].name;
        Serial.println(path_folder);
      }

      loadfolder_files(path_folder);
      // Load the file/folder information into the array

      // Reset the current, first, and last indices
      currentIndex = 0;
      firstIndex = 0;
      lastIndex = min(fileCount - 1, SCREEN_HEIGHT / 8 - 1);

      // Update the display
      displayList();
    }
    else
    {
      Serial.println(fileList[currentIndex].name);
      fileToTransmit = fileList[currentIndex].name;
    }
  }

  if (digitalRead(RETURN_BUTTON_PIN) == LOW)
  {
    delay(500);
    Serial.println("reutrn working");
    loadFiles();
    currentIndex = 0;
    firstIndex = 0;
    lastIndex = min(fileCount - 1, SCREEN_HEIGHT / 8 - 1);
    displayList();
    fold = false;
    path_folder = "";
  }
}
void sendSamples(int samples[], int samplesLenght) {
  Serial.print("Transmitting ");
  Serial.print(samplesLenght);
  Serial.println(" Samples");

  int totalDelay = 0;
  unsigned long time;
  byte n = 0;

  for (int i = 0; i < samplesLenght; i++) {
    // TRANSMIT
    n = 1;

    totalDelay = samples[i] + 0;
    if (totalDelay < 0) {
      // DONT TRANSMIT
      totalDelay = totalDelay * -1;
      n = 0;
    }

    digitalWrite(CCGDO0, n);

    //time = micros();
    //while(micros() < time+totalDelay);
    delayMicroseconds(totalDelay);
  }

  // STOP TRANSMITTING
  digitalWrite(CCGDO0, 0);

  Serial.println("Transmission completed.");
}

void loadFiles()
{
  // Clear the file list array and reset the file count
  memset(fileList, 0, sizeof(fileList));
  fileCount = 0;

  // Open the current directory
  File directory = SD.open("/");

  // Iterate over the files/folders in the directory
  for (File file = directory.openNextFile(); file && fileCount < MAX_FILE_COUNT; file = directory.openNextFile())
  {
    // Check if the file/folder name is too long
    if (strlen(file.name()) > MAX_NAME_LENGTH)
    {
      continue;
    }

    // Copy the file/folder name into the array
    strcpy(fileList[fileCount].name, file.name());
    Serial.println(file.name());
    // Check if the file is a folder
    fileList[fileCount].isFolder = file.isDirectory();

    // Increment the file count
    fileCount++;
  }
  Serial.println(fileCount);
  // Close the directory
  directory.close();
}

void loadfolder_files(String folder_name)
{
  // Clear the file list array and reset the file count
  memset(fileList, 0, sizeof(fileList));
  fileCount = 0;

  // Open the current directory
  File directory = SD.open(folder_name);

  // Iterate over the files/folders in the directory
  for (File file = directory.openNextFile(); file && fileCount < MAX_FILE_COUNT; file = directory.openNextFile())
  {
    // Check if the file/folder name is too long
    if (strlen(file.name()) > MAX_NAME_LENGTH)
    {
      continue;
    }

    // Copy the file/folder name into the array
    strcpy(fileList[fileCount].name, file.name());
    Serial.println(file.name());
    // Check if the file is a folder
    fileList[fileCount].isFolder = file.isDirectory();

    // Increment the file count
    fileCount++;
  }
  Serial.println(fileCount);
  // Close the directory
  directory.close();
}

void displayList()
{
  // Clear the display
  display.clearDisplay();

  // Draw the file/folder list
  int y = 0;
  for (int i = firstIndex; i <= lastIndex; i++)
  {
    // Check if the current index is out of range
    if (i >= fileCount)
    {

      break;
    }

    // Draw the rectangle for the current row
    if (i == currentIndex)
    {
      display.drawRect(0, y, SCREEN_WIDTH, 8, WHITE);
    }

    // Print the file/folder name
    display.setCursor(2, y + 1);
    display.print(fileList[i].name);

    // Move to the next row
    y += 8;
  }

  // Display the contents of the display buffer
  display.display();
}

int compareFileInfo(const void *a, const void *b) {
  // Convert the void pointers to FileInfo pointers
  FileInfo *infoA = (FileInfo *)a;
  FileInfo *infoB = (FileInfo *)b;

  // Compare the file/folder names
  return strcasecmp(infoA->name, infoB->name);
}
